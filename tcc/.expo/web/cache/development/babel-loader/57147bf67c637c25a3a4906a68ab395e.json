{"ast":null,"code":"import { defineAnimation } from \"./util\";\nexport function withDelay(delayMs, _nextAnimation) {\n  'worklet';\n\n  return defineAnimation(_nextAnimation, function () {\n    'worklet';\n\n    var nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function delay(animation, now) {\n      var startTime = animation.startTime,\n          started = animation.started,\n          previousAnimation = animation.previousAnimation;\n\n      if (now - startTime > delayMs) {\n        if (!started) {\n          nextAnimation.onStart(nextAnimation, animation.current, now, previousAnimation);\n          animation.previousAnimation = null;\n          animation.started = true;\n        }\n\n        var finished = nextAnimation.onFrame(nextAnimation, now);\n        animation.current = nextAnimation.current;\n        return finished;\n      } else if (previousAnimation) {\n        var _finished = previousAnimation.finished || previousAnimation.onFrame(previousAnimation, now);\n\n        animation.current = previousAnimation.current;\n\n        if (_finished) {\n          animation.previousAnimation = null;\n        }\n      }\n\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.startTime = now;\n      animation.started = false;\n      animation.current = value;\n\n      if (previousAnimation === animation) {\n        animation.previousAnimation = previousAnimation.previousAnimation;\n      } else {\n        animation.previousAnimation = previousAnimation;\n      }\n    }\n\n    var callback = function callback(finished) {\n      if (nextAnimation.callback) {\n        nextAnimation.callback(finished);\n      }\n    };\n\n    return {\n      isHigherOrder: true,\n      onFrame: delay,\n      onStart: onStart,\n      current: nextAnimation.current,\n      callback: callback,\n      previousAnimation: null,\n      startTime: 0,\n      started: false\n    };\n  });\n}\nexport function delay(delayMs, _nextAnimation) {\n  'worklet';\n\n  console.warn('Method `delay` is deprecated. Please use `withDelay` instead');\n  return withDelay(delayMs, _nextAnimation);\n}","map":{"version":3,"sources":["C:/Users/Gigio/Desktop/SENAI/Eletronicos/tcc/node_modules/react-native-reanimated/lib/reanimated2/animation/delay.js"],"names":["defineAnimation","withDelay","delayMs","_nextAnimation","nextAnimation","delay","animation","now","startTime","started","previousAnimation","onStart","current","finished","onFrame","value","callback","isHigherOrder","console","warn"],"mappings":"AAAA,SAASA,eAAT;AACA,OAAO,SAASC,SAAT,CAAmBC,OAAnB,EAA4BC,cAA5B,EAA4C;AAC/C;;AACA,SAAOH,eAAe,CAACG,cAAD,EAAiB,YAAM;AACzC;;AACA,QAAMC,aAAa,GAAG,OAAOD,cAAP,KAA0B,UAA1B,GAAuCA,cAAc,EAArD,GAA0DA,cAAhF;;AACA,aAASE,KAAT,CAAeC,SAAf,EAA0BC,GAA1B,EAA+B;AAC3B,UAAQC,SAAR,GAAkDF,SAAlD,CAAQE,SAAR;AAAA,UAAmBC,OAAnB,GAAkDH,SAAlD,CAAmBG,OAAnB;AAAA,UAA4BC,iBAA5B,GAAkDJ,SAAlD,CAA4BI,iBAA5B;;AACA,UAAIH,GAAG,GAAGC,SAAN,GAAkBN,OAAtB,EAA+B;AAC3B,YAAI,CAACO,OAAL,EAAc;AACVL,UAAAA,aAAa,CAACO,OAAd,CAAsBP,aAAtB,EAAqCE,SAAS,CAACM,OAA/C,EAAwDL,GAAxD,EAA6DG,iBAA7D;AACAJ,UAAAA,SAAS,CAACI,iBAAV,GAA8B,IAA9B;AACAJ,UAAAA,SAAS,CAACG,OAAV,GAAoB,IAApB;AACH;;AACD,YAAMI,QAAQ,GAAGT,aAAa,CAACU,OAAd,CAAsBV,aAAtB,EAAqCG,GAArC,CAAjB;AACAD,QAAAA,SAAS,CAACM,OAAV,GAAoBR,aAAa,CAACQ,OAAlC;AACA,eAAOC,QAAP;AACH,OATD,MAUK,IAAIH,iBAAJ,EAAuB;AACxB,YAAMG,SAAQ,GAAGH,iBAAiB,CAACG,QAAlB,IACbH,iBAAiB,CAACI,OAAlB,CAA0BJ,iBAA1B,EAA6CH,GAA7C,CADJ;;AAEAD,QAAAA,SAAS,CAACM,OAAV,GAAoBF,iBAAiB,CAACE,OAAtC;;AACA,YAAIC,SAAJ,EAAc;AACVP,UAAAA,SAAS,CAACI,iBAAV,GAA8B,IAA9B;AACH;AACJ;;AACD,aAAO,KAAP;AACH;;AACD,aAASC,OAAT,CAAiBL,SAAjB,EAA4BS,KAA5B,EAAmCR,GAAnC,EAAwCG,iBAAxC,EAA2D;AACvDJ,MAAAA,SAAS,CAACE,SAAV,GAAsBD,GAAtB;AACAD,MAAAA,SAAS,CAACG,OAAV,GAAoB,KAApB;AACAH,MAAAA,SAAS,CAACM,OAAV,GAAoBG,KAApB;;AACA,UAAIL,iBAAiB,KAAKJ,SAA1B,EAAqC;AACjCA,QAAAA,SAAS,CAACI,iBAAV,GAA8BA,iBAAiB,CAACA,iBAAhD;AACH,OAFD,MAGK;AACDJ,QAAAA,SAAS,CAACI,iBAAV,GAA8BA,iBAA9B;AACH;AACJ;;AACD,QAAMM,QAAQ,GAAG,SAAXA,QAAW,CAACH,QAAD,EAAc;AAC3B,UAAIT,aAAa,CAACY,QAAlB,EAA4B;AACxBZ,QAAAA,aAAa,CAACY,QAAd,CAAuBH,QAAvB;AACH;AACJ,KAJD;;AAKA,WAAO;AACHI,MAAAA,aAAa,EAAE,IADZ;AAEHH,MAAAA,OAAO,EAAET,KAFN;AAGHM,MAAAA,OAAO,EAAPA,OAHG;AAIHC,MAAAA,OAAO,EAAER,aAAa,CAACQ,OAJpB;AAKHI,MAAAA,QAAQ,EAARA,QALG;AAMHN,MAAAA,iBAAiB,EAAE,IANhB;AAOHF,MAAAA,SAAS,EAAE,CAPR;AAQHC,MAAAA,OAAO,EAAE;AARN,KAAP;AAUH,GAnDqB,CAAtB;AAoDH;AAID,OAAO,SAASJ,KAAT,CAAeH,OAAf,EAAwBC,cAAxB,EAAwC;AAC3C;;AACAe,EAAAA,OAAO,CAACC,IAAR,CAAa,8DAAb;AACA,SAAOlB,SAAS,CAACC,OAAD,EAAUC,cAAV,CAAhB;AACH","sourcesContent":["import { defineAnimation } from './util';\r\nexport function withDelay(delayMs, _nextAnimation) {\r\n    'worklet';\r\n    return defineAnimation(_nextAnimation, () => {\r\n        'worklet';\r\n        const nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\r\n        function delay(animation, now) {\r\n            const { startTime, started, previousAnimation } = animation;\r\n            if (now - startTime > delayMs) {\r\n                if (!started) {\r\n                    nextAnimation.onStart(nextAnimation, animation.current, now, previousAnimation);\r\n                    animation.previousAnimation = null;\r\n                    animation.started = true;\r\n                }\r\n                const finished = nextAnimation.onFrame(nextAnimation, now);\r\n                animation.current = nextAnimation.current;\r\n                return finished;\r\n            }\r\n            else if (previousAnimation) {\r\n                const finished = previousAnimation.finished ||\r\n                    previousAnimation.onFrame(previousAnimation, now);\r\n                animation.current = previousAnimation.current;\r\n                if (finished) {\r\n                    animation.previousAnimation = null;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        function onStart(animation, value, now, previousAnimation) {\r\n            animation.startTime = now;\r\n            animation.started = false;\r\n            animation.current = value;\r\n            if (previousAnimation === animation) {\r\n                animation.previousAnimation = previousAnimation.previousAnimation;\r\n            }\r\n            else {\r\n                animation.previousAnimation = previousAnimation;\r\n            }\r\n        }\r\n        const callback = (finished) => {\r\n            if (nextAnimation.callback) {\r\n                nextAnimation.callback(finished);\r\n            }\r\n        };\r\n        return {\r\n            isHigherOrder: true,\r\n            onFrame: delay,\r\n            onStart,\r\n            current: nextAnimation.current,\r\n            callback,\r\n            previousAnimation: null,\r\n            startTime: 0,\r\n            started: false,\r\n        };\r\n    });\r\n}\r\n/**\r\n * @deprecated Kept for backward compatibility. Will be removed soon.\r\n */\r\nexport function delay(delayMs, _nextAnimation) {\r\n    'worklet';\r\n    console.warn('Method `delay` is deprecated. Please use `withDelay` instead');\r\n    return withDelay(delayMs, _nextAnimation);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}