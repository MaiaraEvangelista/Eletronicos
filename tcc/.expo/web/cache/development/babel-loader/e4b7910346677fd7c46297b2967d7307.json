{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"C:\\\\Users\\\\Gigio\\\\Desktop\\\\copia tcc\\\\tcc\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\createAnimatedComponent.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport ReanimatedEventEmitter from \"./ReanimatedEventEmitter\";\nimport AnimatedEvent from \"./reanimated1/core/AnimatedEvent\";\nimport AnimatedNode from \"./reanimated1/core/AnimatedNode\";\nimport AnimatedValue from \"./reanimated1/core/AnimatedValue\";\nimport { createOrReusePropsNode } from \"./reanimated1/core/AnimatedProps\";\nimport WorkletEventHandler from \"./reanimated2/WorkletEventHandler\";\nimport setAndForwardRef from \"./setAndForwardRef\";\nimport \"./reanimated2/layoutReanimation/LayoutAnimationRepository\";\nimport invariant from 'invariant';\nimport { adaptViewConfig } from \"./ConfigHelper\";\nimport { RNRenderer } from \"./reanimated2/platform-specific/RNRenderer\";\nimport { makeMutable, runOnUI } from \"./reanimated2/core\";\nimport { DefaultEntering, DefaultExiting, DefaultLayout } from \"./reanimated2/layoutReanimation/defaultAnimations/Default\";\nimport { isJest, isChromeDebugger } from \"./reanimated2/PlatformChecker\";\nimport { initialUpdaterRun } from \"./reanimated2/animation\";\nvar NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  var component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {}\n\nfunction hasAnimatedNodes(value) {\n  if (value instanceof AnimatedNode) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.some(function (item) {\n      return hasAnimatedNodes(item);\n    });\n  }\n\n  if (value && typeof value === 'object') {\n    return Object.keys(value).some(function (key) {\n      return hasAnimatedNodes(value[key]);\n    });\n  }\n\n  return false;\n}\n\nfunction flattenArray(array) {\n  if (!Array.isArray(array)) {\n    return [array];\n  }\n\n  var resultArr = [];\n\n  var _flattenArray = function _flattenArray(arr) {\n    arr.forEach(function (item) {\n      if (Array.isArray(item)) {\n        _flattenArray(item);\n      } else {\n        resultArr.push(item);\n      }\n    });\n  };\n\n  _flattenArray(array);\n\n  return resultArr;\n}\n\nexport default function createAnimatedComponent(Component) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  invariant(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n\n  var AnimatedComponent = function (_React$Component) {\n    _inherits(AnimatedComponent, _React$Component);\n\n    var _super = _createSuper(AnimatedComponent);\n\n    function AnimatedComponent(props) {\n      var _this;\n\n      _classCallCheck(this, AnimatedComponent);\n\n      _this = _super.call(this, props);\n      _this._invokeAnimatedPropsCallbackOnMount = false;\n      _this._styles = null;\n      _this._viewTag = -1;\n      _this._isFirstRender = true;\n\n      _this._animatedPropsCallback = function () {\n        if (_this._component == null) {\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else {\n          _this._component.setNativeProps(_this._propsAnimated.__getValue());\n        }\n      };\n\n      _this._setComponentRef = setAndForwardRef({\n        getForwardedRef: function getForwardedRef() {\n          return _this.props.forwardedRef;\n        },\n        setLocalRef: function setLocalRef(ref) {\n          var tag = findNodeHandle(ref);\n\n          if ((_this.props.layout || _this.props.entering || _this.props.exiting) && tag != null) {\n            var layout = _this.props.layout ? _this.props.layout : DefaultLayout;\n            var entering = _this.props.entering ? _this.props.entering : DefaultEntering;\n            var exiting = _this.props.exiting ? _this.props.exiting : DefaultExiting;\n\n            if (layout.build) {\n              layout = layout.build();\n            }\n\n            if (entering.build) {\n              entering = entering.build();\n            }\n\n            if (exiting.build) {\n              exiting = exiting.build();\n            }\n\n            var config = {\n              layout: layout,\n              entering: entering,\n              exiting: exiting,\n              sv: _this.sv\n            };\n            runOnUI(function () {\n              'worklet';\n\n              global.LayoutAnimationRepository.registerConfig(tag, config);\n            })();\n          }\n\n          if (ref !== _this._component) {\n            _this._component = ref;\n          }\n\n          if (ref != null && ref.getNode == null) {\n            ref.getNode = function () {\n              var _ref$constructor$name;\n\n              console.warn('%s: Calling %s on the ref of an Animated component ' + 'is no longer necessary. You can now directly use the ref ' + 'instead. This method will be removed in a future release.', (_ref$constructor$name = ref.constructor.name) != null ? _ref$constructor$name : '<<anonymous>>', 'getNode()');\n              return ref;\n            };\n          }\n        }\n      });\n\n      _this._attachProps(_this.props);\n\n      if (isJest()) {\n        _this.animatedStyle = {\n          value: {}\n        };\n      }\n\n      _this.sv = makeMutable({});\n      return _this;\n    }\n\n    _createClass(AnimatedComponent, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._detachPropUpdater();\n\n        this._propsAnimated && this._propsAnimated.__detach();\n\n        this._detachNativeEvents();\n\n        this._detachStyles();\n\n        this.sv = null;\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this._invokeAnimatedPropsCallbackOnMount) {\n          this._invokeAnimatedPropsCallbackOnMount = false;\n\n          this._animatedPropsCallback();\n        }\n\n        this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n\n        this._attachNativeEvents();\n\n        this._attachPropUpdater();\n\n        this._attachAnimatedStyles();\n      }\n    }, {\n      key: \"_getEventViewRef\",\n      value: function _getEventViewRef() {\n        return this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n      }\n    }, {\n      key: \"_attachNativeEvents\",\n      value: function _attachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        var viewTag = findNodeHandle(options.setNativeProps ? this : node);\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof AnimatedEvent) {\n            prop.attachEvent(node, key);\n          } else if (prop != null && prop.current && prop.current instanceof WorkletEventHandler) {\n            prop.current.registerForEvents(viewTag, key);\n          }\n        }\n      }\n    }, {\n      key: \"_detachNativeEvents\",\n      value: function _detachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof AnimatedEvent) {\n            prop.detachEvent(node, key);\n          } else if (prop != null && prop.current && prop.current instanceof WorkletEventHandler) {\n            prop.current.unregisterFromEvents();\n          }\n        }\n      }\n    }, {\n      key: \"_detachStyles\",\n      value: function _detachStyles() {\n        if (Platform.OS === 'web') {\n          for (var _iterator = _createForOfIteratorHelperLoose(this._styles), _step; !(_step = _iterator()).done;) {\n            var style = _step.value;\n\n            if (style != null && style.viewsRef) {\n              style.viewsRef.remove(this);\n            }\n          }\n        } else if (this._viewTag !== -1) {\n          var _this$props$animatedP;\n\n          for (var _iterator2 = _createForOfIteratorHelperLoose(this._styles), _step2; !(_step2 = _iterator2()).done;) {\n            var _style = _step2.value;\n\n            if (_style != null && _style.viewDescriptors) {\n              _style.viewDescriptors.remove(this._viewTag);\n            }\n          }\n\n          if ((_this$props$animatedP = this.props.animatedProps) != null && _this$props$animatedP.viewDescriptors) {\n            this.props.animatedProps.viewDescriptors.remove(this._viewTag);\n          }\n        }\n      }\n    }, {\n      key: \"_reattachNativeEvents\",\n      value: function _reattachNativeEvents(prevProps) {\n        var node = this._getEventViewRef();\n\n        var attached = new Set();\n        var nextEvts = new Set();\n        var viewTag;\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof AnimatedEvent) {\n            nextEvts.add(prop.__nodeID);\n          } else if (prop != null && prop.current && prop.current instanceof WorkletEventHandler) {\n            if (viewTag === undefined) {\n              viewTag = prop.current.viewTag;\n            }\n          }\n        }\n\n        for (var _key in prevProps) {\n          var _prop = this.props[_key];\n\n          if (_prop instanceof AnimatedEvent) {\n            if (!nextEvts.has(_prop.__nodeID)) {\n              _prop.detachEvent(node, _key);\n            } else {\n              attached.add(_prop.__nodeID);\n            }\n          } else if (_prop != null && _prop.current && _prop.current instanceof WorkletEventHandler && _prop.current.reattachNeeded) {\n            _prop.current.unregisterFromEvents();\n          }\n        }\n\n        for (var _key2 in this.props) {\n          var _prop2 = this.props[_key2];\n\n          if (_prop2 instanceof AnimatedEvent && !attached.has(_prop2.__nodeID)) {\n            _prop2.attachEvent(node, _key2);\n          } else if (_prop2 != null && _prop2.current && _prop2.current instanceof WorkletEventHandler && _prop2.current.reattachNeeded) {\n            _prop2.current.registerForEvents(viewTag, _key2);\n\n            _prop2.current.reattachNeeded = false;\n          }\n        }\n      }\n    }, {\n      key: \"_attachProps\",\n      value: function _attachProps(nextProps) {\n        var oldPropsAnimated = this._propsAnimated;\n        this._propsAnimated = createOrReusePropsNode(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n\n        if (oldPropsAnimated !== this._propsAnimated) {\n          oldPropsAnimated && oldPropsAnimated.__detach();\n        }\n      }\n    }, {\n      key: \"_updateFromNative\",\n      value: function _updateFromNative(props) {\n        if (options.setNativeProps) {\n          options.setNativeProps(this._component, props);\n        } else {\n          var _this$_component$setN, _this$_component;\n\n          (_this$_component$setN = (_this$_component = this._component).setNativeProps) == null ? void 0 : _this$_component$setN.call(_this$_component, props);\n        }\n      }\n    }, {\n      key: \"_attachPropUpdater\",\n      value: function _attachPropUpdater() {\n        var viewTag = findNodeHandle(this);\n        NODE_MAPPING.set(viewTag, this);\n\n        if (NODE_MAPPING.size === 1) {\n          ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n        }\n      }\n    }, {\n      key: \"_attachAnimatedStyles\",\n      value: function _attachAnimatedStyles() {\n        var _this2 = this,\n            _this$props$animatedP2;\n\n        var styles = flattenArray(this.props.style);\n        this._styles = styles;\n        var viewTag, viewName;\n\n        if (Platform.OS === 'web') {\n          viewTag = findNodeHandle(this);\n          viewName = null;\n        } else {\n          var _hostInstance$viewCon;\n\n          var hostInstance = RNRenderer.findHostInstance_DEPRECATED(this);\n\n          if (!hostInstance) {\n            throw new Error('Cannot find host instance for this component. Maybe it renders nothing?');\n          }\n\n          viewTag = hostInstance == null ? void 0 : hostInstance._nativeTag;\n          viewName = hostInstance == null ? void 0 : (_hostInstance$viewCon = hostInstance.viewConfig) == null ? void 0 : _hostInstance$viewCon.uiViewClassName;\n\n          if (hostInstance && this._hasReanimated2Props(styles) && hostInstance.viewConfig) {\n            adaptViewConfig(hostInstance.viewConfig);\n          }\n        }\n\n        this._viewTag = viewTag;\n        styles.forEach(function (style) {\n          if (style != null && style.viewDescriptors) {\n            style.viewDescriptors.add({\n              tag: viewTag,\n              name: viewName\n            });\n\n            if (isJest()) {\n              _this2.animatedStyle.value = _objectSpread(_objectSpread({}, _this2.animatedStyle.value), style.initial.value);\n              style.animatedStyle.current = _this2.animatedStyle;\n            }\n          }\n        });\n\n        if ((_this$props$animatedP2 = this.props.animatedProps) != null && _this$props$animatedP2.viewDescriptors) {\n          this.props.animatedProps.viewDescriptors.add({\n            tag: viewTag,\n            name: viewName\n          });\n        }\n      }\n    }, {\n      key: \"_hasReanimated2Props\",\n      value: function _hasReanimated2Props(flattenStyles) {\n        var _this$props$animatedP3;\n\n        if ((_this$props$animatedP3 = this.props.animatedProps) != null && _this$props$animatedP3.viewDescriptors) {\n          return true;\n        }\n\n        if (this.props.style) {\n          for (var _iterator3 = _createForOfIteratorHelperLoose(flattenStyles), _step3; !(_step3 = _iterator3()).done;) {\n            var style = _step3.value;\n\n            if (style != null && style.hasOwnProperty('viewDescriptors')) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }\n    }, {\n      key: \"_detachPropUpdater\",\n      value: function _detachPropUpdater() {\n        var viewTag = findNodeHandle(this);\n        NODE_MAPPING.delete(viewTag);\n\n        if (NODE_MAPPING.size === 0) {\n          ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this._attachProps(this.props);\n\n        this._reattachNativeEvents(prevProps);\n\n        this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n\n        this._attachAnimatedStyles();\n      }\n    }, {\n      key: \"_filterNonAnimatedStyle\",\n      value: function _filterNonAnimatedStyle(inputStyle) {\n        var style = {};\n\n        for (var key in inputStyle) {\n          var value = inputStyle[key];\n\n          if (!hasAnimatedNodes(value)) {\n            style[key] = value;\n          } else if (value instanceof AnimatedValue) {\n            style[key] = value._startingValue;\n          }\n        }\n\n        return style;\n      }\n    }, {\n      key: \"_filterNonAnimatedProps\",\n      value: function _filterNonAnimatedProps(inputProps) {\n        var _this3 = this;\n\n        var props = {};\n\n        var _loop = function _loop(key) {\n          var value = inputProps[key];\n\n          if (key === 'style') {\n            var styles = flattenArray(value);\n            var processedStyle = styles.map(function (style) {\n              if (style && style.viewDescriptors) {\n                style.viewsRef.add(_this3);\n\n                if (_this3._isFirstRender) {\n                  return _objectSpread(_objectSpread({}, style.initial.value), initialUpdaterRun(style.initial.updater));\n                } else {\n                  return style.initial.value;\n                }\n              } else {\n                return style;\n              }\n            });\n            props[key] = _this3._filterNonAnimatedStyle(StyleSheet.flatten(processedStyle));\n          } else if (key === 'animatedProps') {\n            Object.keys(value.initial.value).forEach(function (key) {\n              props[key] = value.initial.value[key];\n              value.viewsRef.add(_this3);\n            });\n          } else if (value instanceof AnimatedEvent) {\n            props[key] = dummyListener;\n          } else if (value != null && value.current && value.current instanceof WorkletEventHandler) {\n            if (value.current.eventNames.length > 0) {\n              value.current.eventNames.forEach(function (eventName) {\n                props[eventName] = value.current.listeners ? value.current.listeners[eventName] : dummyListener;\n              });\n            } else {\n              props[key] = dummyListener;\n            }\n          } else if (!(value instanceof AnimatedNode)) {\n            if (key !== 'onGestureHandlerStateChange' || !isChromeDebugger()) {\n              props[key] = value;\n            }\n          } else if (value instanceof AnimatedValue) {\n            props[key] = value._startingValue;\n          }\n        };\n\n        for (var key in inputProps) {\n          _loop(key);\n        }\n\n        return props;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var props = this._filterNonAnimatedProps(this.props);\n\n        if (isJest()) {\n          props.animatedStyle = this.animatedStyle;\n        }\n\n        if (this._isFirstRender) {\n          this._isFirstRender = false;\n        }\n\n        var platformProps = Platform.select({\n          web: {},\n          default: {\n            collapsable: false\n          }\n        });\n        return React.createElement(Component, _extends({}, props, {\n          ref: this._setComponentRef\n        }, platformProps, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 528,\n            columnNumber: 9\n          }\n        }));\n      }\n    }]);\n\n    return AnimatedComponent;\n  }(React.Component);\n\n  AnimatedComponent.displayName = \"AnimatedComponent(\" + (Component.displayName || Component.name || 'Component') + \")\";\n  return React.forwardRef(function AnimatedComponentWrapper(props, ref) {\n    return React.createElement(AnimatedComponent, _extends({}, props, ref == null ? null : {\n      forwardedRef: ref\n    }, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 539,\n        columnNumber: 7\n      }\n    }));\n  });\n}","map":{"version":3,"sources":["C:/Users/Gigio/Desktop/copia tcc/tcc/node_modules/react-native-reanimated/lib/createAnimatedComponent.js"],"names":["React","ReanimatedEventEmitter","AnimatedEvent","AnimatedNode","AnimatedValue","createOrReusePropsNode","WorkletEventHandler","setAndForwardRef","invariant","adaptViewConfig","RNRenderer","makeMutable","runOnUI","DefaultEntering","DefaultExiting","DefaultLayout","isJest","isChromeDebugger","initialUpdaterRun","NODE_MAPPING","Map","listener","data","component","get","viewTag","_updateFromNative","props","dummyListener","hasAnimatedNodes","value","Array","isArray","some","item","Object","keys","key","flattenArray","array","resultArr","_flattenArray","arr","forEach","push","createAnimatedComponent","Component","options","prototype","isReactComponent","AnimatedComponent","_invokeAnimatedPropsCallbackOnMount","_styles","_viewTag","_isFirstRender","_animatedPropsCallback","_component","setNativeProps","forceUpdate","_propsAnimated","__getValue","_setComponentRef","getForwardedRef","forwardedRef","setLocalRef","ref","tag","findNodeHandle","layout","entering","exiting","build","config","sv","global","LayoutAnimationRepository","registerConfig","getNode","console","warn","constructor","name","_attachProps","animatedStyle","_detachPropUpdater","__detach","_detachNativeEvents","_detachStyles","setNativeView","_attachNativeEvents","_attachPropUpdater","_attachAnimatedStyles","getScrollableNode","node","_getEventViewRef","prop","attachEvent","current","registerForEvents","detachEvent","unregisterFromEvents","Platform","OS","style","viewsRef","remove","viewDescriptors","animatedProps","prevProps","attached","Set","nextEvts","add","__nodeID","undefined","has","reattachNeeded","nextProps","oldPropsAnimated","set","size","addListener","styles","viewName","hostInstance","findHostInstance_DEPRECATED","Error","_nativeTag","viewConfig","uiViewClassName","_hasReanimated2Props","initial","flattenStyles","hasOwnProperty","delete","removeAllListeners","_reattachNativeEvents","inputStyle","_startingValue","inputProps","processedStyle","map","updater","_filterNonAnimatedStyle","StyleSheet","flatten","eventNames","length","eventName","listeners","_filterNonAnimatedProps","platformProps","select","web","default","collapsable","displayName","forwardRef","AnimatedComponentWrapper"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './reanimated1/core/AnimatedEvent';\nimport AnimatedNode from './reanimated1/core/AnimatedNode';\nimport AnimatedValue from './reanimated1/core/AnimatedValue';\nimport { createOrReusePropsNode } from './reanimated1/core/AnimatedProps';\nimport WorkletEventHandler from './reanimated2/WorkletEventHandler';\nimport setAndForwardRef from './setAndForwardRef';\nimport './reanimated2/layoutReanimation/LayoutAnimationRepository';\n\nimport invariant from 'invariant';\nimport { adaptViewConfig } from './ConfigHelper';\nimport { RNRenderer } from './reanimated2/platform-specific/RNRenderer';\nimport { makeMutable, runOnUI } from './reanimated2/core';\nimport {\n  DefaultEntering,\n  DefaultExiting,\n  DefaultLayout,\n} from './reanimated2/layoutReanimation/defaultAnimations/Default';\nimport { isJest, isChromeDebugger } from './reanimated2/PlatformChecker';\nimport { initialUpdaterRun } from './reanimated2/animation';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {\n  // empty listener we use to assign to listener properties for which animated\n  // event is used.\n}\n\nfunction hasAnimatedNodes(value) {\n  if (value instanceof AnimatedNode) {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.some((item) => hasAnimatedNodes(item));\n  }\n  if (value && typeof value === 'object') {\n    return Object.keys(value).some((key) => hasAnimatedNodes(value[key]));\n  }\n  return false;\n}\n\nfunction flattenArray(array) {\n  if (!Array.isArray(array)) {\n    return [array];\n  }\n  const resultArr = [];\n\n  const _flattenArray = (arr) => {\n    arr.forEach((item) => {\n      if (Array.isArray(item)) {\n        _flattenArray(item);\n      } else {\n        resultArr.push(item);\n      }\n    });\n  };\n  _flattenArray(array);\n  return resultArr;\n}\n\nexport default function createAnimatedComponent(Component, options = {}) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n    _styles = null;\n    _viewTag = -1;\n    _isFirstRender = true;\n\n    constructor(props) {\n      super(props);\n      this._attachProps(this.props);\n      if (isJest()) {\n        this.animatedStyle = { value: {} };\n      }\n      this.sv = makeMutable({});\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n      this._detachStyles();\n      this.sv = null;\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n      this._attachAnimatedStyles();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n      const viewTag = findNodeHandle(options.setNativeProps ? this : node);\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler\n        ) {\n          prop.current.registerForEvents(viewTag, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler\n        ) {\n          prop.current.unregisterFromEvents();\n        }\n      }\n    }\n\n    _detachStyles() {\n      if (Platform.OS === 'web') {\n        for (const style of this._styles) {\n          if (style?.viewsRef) {\n            style.viewsRef.remove(this);\n          }\n        }\n      } else if (this._viewTag !== -1) {\n        for (const style of this._styles) {\n          if (style?.viewDescriptors) {\n            style.viewDescriptors.remove(this._viewTag);\n          }\n        }\n        if (this.props.animatedProps?.viewDescriptors) {\n          this.props.animatedProps.viewDescriptors.remove(this._viewTag);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      let viewTag;\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler\n        ) {\n          if (viewTag === undefined) {\n            viewTag = prop.current.viewTag;\n          }\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler &&\n          prop.current.reattachNeeded\n        ) {\n          prop.current.unregisterFromEvents();\n        }\n      }\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        } else if (\n          prop?.current &&\n          prop.current instanceof WorkletEventHandler &&\n          prop.current.reattachNeeded\n        ) {\n          prop.current.registerForEvents(viewTag, key);\n          prop.current.reattachNeeded = false;\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      if (options.setNativeProps) {\n        options.setNativeProps(this._component, props);\n      } else {\n        // eslint-disable-next-line no-unused-expressions\n        this._component.setNativeProps?.(props);\n      }\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _attachAnimatedStyles() {\n      const styles = flattenArray(this.props.style);\n      this._styles = styles;\n      let viewTag, viewName;\n      if (Platform.OS === 'web') {\n        viewTag = findNodeHandle(this);\n        viewName = null;\n      } else {\n        // hostInstance can be null for a component that doesn't render anything (render function returns null). Example: svg Stop: https://github.com/react-native-svg/react-native-svg/blob/develop/src/elements/Stop.tsx\n        const hostInstance = RNRenderer.findHostInstance_DEPRECATED(this);\n        if (!hostInstance) {\n          throw new Error(\n            'Cannot find host instance for this component. Maybe it renders nothing?'\n          );\n        }\n        // we can access view tag in the same way it's accessed here https://github.com/facebook/react/blob/e3f4eb7272d4ca0ee49f27577156b57eeb07cf73/packages/react-native-renderer/src/ReactFabric.js#L146\n        viewTag = hostInstance?._nativeTag;\n        /**\n         * RN uses viewConfig for components for storing different properties of the component(example: https://github.com/facebook/react-native/blob/master/Libraries/Components/ScrollView/ScrollViewViewConfig.js#L16).\n         * The name we're looking for is in the field named uiViewClassName.\n         */\n        viewName = hostInstance?.viewConfig?.uiViewClassName;\n        // update UI props whitelist for this view\n        if (\n          hostInstance &&\n          this._hasReanimated2Props(styles) &&\n          hostInstance.viewConfig\n        ) {\n          adaptViewConfig(hostInstance.viewConfig);\n        }\n      }\n      this._viewTag = viewTag;\n\n      styles.forEach((style) => {\n        if (style?.viewDescriptors) {\n          style.viewDescriptors.add({ tag: viewTag, name: viewName });\n          if (isJest()) {\n            /**\n             * We need to connect Jest's TestObject instance whose contains just props object\n             * with the updateProps() function where we update the properties of the component.\n             * We can't update props object directly because TestObject contains a copy of props - look at render function:\n             * const props = this._filterNonAnimatedProps(this.props);\n             */\n            this.animatedStyle.value = {\n              ...this.animatedStyle.value,\n              ...style.initial.value,\n            };\n            style.animatedStyle.current = this.animatedStyle;\n          }\n        }\n      });\n      // attach animatedProps property\n      if (this.props.animatedProps?.viewDescriptors) {\n        this.props.animatedProps.viewDescriptors.add({\n          tag: viewTag,\n          name: viewName,\n        });\n      }\n    }\n\n    _hasReanimated2Props(flattenStyles) {\n      if (this.props.animatedProps?.viewDescriptors) {\n        return true;\n      }\n      if (this.props.style) {\n        for (const style of flattenStyles) {\n          // eslint-disable-next-line no-prototype-builtins\n          if (style?.hasOwnProperty('viewDescriptors')) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n      this._attachAnimatedStyles();\n    }\n\n    _setComponentRef = setAndForwardRef({\n      getForwardedRef: () => this.props.forwardedRef,\n      setLocalRef: (ref) => {\n        // TODO update config\n        const tag = findNodeHandle(ref);\n        if (\n          (this.props.layout || this.props.entering || this.props.exiting) &&\n          tag != null\n        ) {\n          let layout = this.props.layout ? this.props.layout : DefaultLayout;\n          let entering = this.props.entering\n            ? this.props.entering\n            : DefaultEntering;\n          let exiting = this.props.exiting\n            ? this.props.exiting\n            : DefaultExiting;\n\n          if (layout.build) {\n            layout = layout.build();\n          }\n\n          if (entering.build) {\n            entering = entering.build();\n          }\n\n          if (exiting.build) {\n            exiting = exiting.build();\n          }\n\n          const config = {\n            layout,\n            entering,\n            exiting,\n            sv: this.sv,\n          };\n          runOnUI(() => {\n            'worklet';\n            global.LayoutAnimationRepository.registerConfig(tag, config);\n          })();\n        }\n\n        if (ref !== this._component) {\n          this._component = ref;\n        }\n\n        // TODO: Delete this after React Native also deletes this deprecation helper.\n        if (ref != null && ref.getNode == null) {\n          ref.getNode = () => {\n            console.warn(\n              '%s: Calling %s on the ref of an Animated component ' +\n                'is no longer necessary. You can now directly use the ref ' +\n                'instead. This method will be removed in a future release.',\n              ref.constructor.name ?? '<<anonymous>>',\n              'getNode()'\n            );\n            return ref;\n          };\n        }\n      },\n    });\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (!hasAnimatedNodes(value)) {\n          style[key] = value;\n        } else if (value instanceof AnimatedValue) {\n          // if any style in animated component is set directly to the `Value` we set those styles to the first value of `Value` node in order\n          // to avoid flash of default styles when `Value` is being asynchrounously sent via bridge and initialized in the native side.\n          style[key] = value._startingValue;\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          const styles = flattenArray(value);\n          const processedStyle = styles.map((style) => {\n            if (style && style.viewDescriptors) {\n              // this is how we recognize styles returned by useAnimatedStyle\n              style.viewsRef.add(this);\n              if (this._isFirstRender) {\n                return {\n                  ...style.initial.value,\n                  ...initialUpdaterRun(style.initial.updater),\n                };\n              } else {\n                return style.initial.value;\n              }\n            } else {\n              return style;\n            }\n          });\n          props[key] = this._filterNonAnimatedStyle(\n            StyleSheet.flatten(processedStyle)\n          );\n        } else if (key === 'animatedProps') {\n          Object.keys(value.initial.value).forEach((key) => {\n            props[key] = value.initial.value[key];\n            value.viewsRef.add(this);\n          });\n        } else if (value instanceof AnimatedEvent) {\n          // we cannot filter out event listeners completely as some components\n          // rely on having a callback registered in order to generate events\n          // alltogether. Therefore we provide a dummy callback here to allow\n          // native event dispatcher to hijack events.\n          props[key] = dummyListener;\n        } else if (\n          value?.current &&\n          value.current instanceof WorkletEventHandler\n        ) {\n          if (value.current.eventNames.length > 0) {\n            value.current.eventNames.forEach((eventName) => {\n              props[eventName] = value.current.listeners\n                ? value.current.listeners[eventName]\n                : dummyListener;\n            });\n          } else {\n            props[key] = dummyListener;\n          }\n        } else if (!(value instanceof AnimatedNode)) {\n          if (key !== 'onGestureHandlerStateChange' || !isChromeDebugger()) {\n            props[key] = value;\n          }\n        } else if (value instanceof AnimatedValue) {\n          // if any prop in animated component is set directly to the `Value` we set those props to the first value of `Value` node in order\n          // to avoid default values for a short moment when `Value` is being asynchrounously sent via bridge and initialized in the native side.\n          props[key] = value._startingValue;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      if (isJest()) {\n        props.animatedStyle = this.animatedStyle;\n      }\n\n      if (this._isFirstRender) {\n        this._isFirstRender = false;\n      }\n\n      const platformProps = Platform.select({\n        web: {},\n        default: { collapsable: false },\n      });\n      return (\n        <Component {...props} ref={this._setComponentRef} {...platformProps} />\n      );\n    }\n  }\n\n  AnimatedComponent.displayName = `AnimatedComponent(${\n    Component.displayName || Component.name || 'Component'\n  })`;\n\n  return React.forwardRef(function AnimatedComponentWrapper(props, ref) {\n    return (\n      <AnimatedComponent\n        {...props}\n        {...(ref == null ? null : { forwardedRef: ref })}\n      />\n    );\n  });\n}\n"]},"metadata":{},"sourceType":"module"}